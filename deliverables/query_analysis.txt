QUESTION 1: Monthly Encounters by Specialty
SQL Query:
``
SELECT 
    DATE_FORMAT(e.encounter_date, '%Y-%m') AS month,
    s.specialty_name,
    e.encounter_type,
    COUNT(e.encounter_id) AS total_encounters,
    COUNT(DISTINCT e.patient_id) AS unique_patients
FROM encounters e
JOIN providers p ON e.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
GROUP BY 
    DATE_FORMAT(e.encounter_date, '%Y-%m'),
    s.specialty_name,
    e.encounter_type
ORDER BY 
    month DESC,
    specialty_name,
    encounter_type;
```

Schema Analysis:
Tables joined: `encounters`, `providers`, `specialties`
Number of joins: 2

Performance:
Execution time: 293 ms
Estimated rows scanned: `encounters` ~30,000

Bottleneck Identified:

* Aggregation with `COUNT` and `COUNT DISTINCT` over multiple joins can be slow on large datasets.
* `DATE_FORMAT` in `GROUP BY` prevents efficient index use on `encounter_date`.

---

QUESTION 2: Top Diagnosis-Procedure Pairs

SQL Query:

```
SELECT 
    d.icd10_code AS ICD,
    p.cpt_code AS Procedure_Code,
    p.cpt_description AS ProcedureDescription,
    COUNT(DISTINCT e.encounter_id) AS Encounter_Count
FROM encounters e
JOIN encounter_diagnoses ed ON e.encounter_id = ed.encounter_id
JOIN diagnoses d ON ed.diagnosis_id = d.diagnosis_id
JOIN encounter_procedures ep ON e.encounter_id = ep.encounter_id
JOIN procedures p ON ep.procedure_id = p.procedure_id
GROUP BY d.icd10_code, p.cpt_code, p.cpt_description
ORDER BY Encounter_Count DESC;
```

Schema Analysis:
Tables joined: `encounters`, `encounter_diagnoses`, `diagnoses`, `encounter_procedures`, `procedures`
Number of joins: 4

Performance:
Execution time: 444 ms
Estimated rows scanned: `encounters` ~30,000

Bottleneck Identified:

* Multiple junction tables (`encounter_diagnoses` and `encounter_procedures`) cause row expansion.
* `COUNT(DISTINCT e.encounter_id)` on large datasets further slows performance.

---

QUESTION 3: 30-Day Readmission Rate

SQL Query:

```
SELECT 
    s.specialty_name,
    COUNT(*) AS readmission_count
FROM encounters e1
JOIN encounters e2 
    ON e1.patient_id = e2.patient_id
    AND e2.encounter_date > e1.discharge_date
    AND e2.encounter_date <= DATE_ADD(e1.discharge_date, INTERVAL 30 DAY)
JOIN providers p ON e1.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
WHERE e1.encounter_type = 'Inpatient'
  AND e2.encounter_type = 'Inpatient'
GROUP BY s.specialty_name
ORDER BY readmission_count DESC;
```

Schema Analysis:
Tables joined: `encounters` (self-join), `providers`, `specialties`
Number of joins: 3

Performance:
Execution time: 128 ms
Estimated rows scanned: `encounters` ~30,000

Bottleneck Identified:

* Self-join on `encounters` increases intermediate rows.
* Filtering with `DATE_ADD` prevents efficient index usage on `discharge_date`.

---

QUESTION 4: Revenue by Specialty & Month

SQL Query:

```
SELECT 
    s.specialty_name AS Specialty_name,
    DATE_FORMAT(e.encounter_date, '%Y-%m') AS Encounter_Month,
    SUM(b.allowed_amount) AS Total_allowed
FROM billing b
JOIN encounters e ON b.encounter_id = e.encounter_id
JOIN providers p ON e.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
GROUP BY s.specialty_name, DATE_FORMAT(e.encounter_date, '%Y-%m')
ORDER BY Encounter_Month DESC, Total_allowed DESC;
```

Schema Analysis:
Tables joined: `billing`, `encounters`, `providers`, `specialties`
Number of joins: 3

Performance:
Execution time: 327 ms
Estimated rows scanned: `billing` + `encounters` ~30,000 each

Bottleneck Identified:

* Aggregation with `SUM` plus multiple joins increases computation.
* `DATE_FORMAT` in `GROUP BY` prevents efficient index usage on `encounter_date`.

